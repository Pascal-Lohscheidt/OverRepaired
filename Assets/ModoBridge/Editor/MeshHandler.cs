using System.Collections.Generic;
using System.Collections.Specialized;
using UnityEditor;
using UnityEngine;

namespace Foundry
{
    /// <summary>
    /// Unmanaged mesh data structure
    /// Used to marshal memory from unmanaged native plugin to managed memory
    /// </summary>
    /// <param name="entityToken">Entity token.</param>
    /// <param name="displayName">Entity display name.</param>
    /// <param name="entityParentToken">Entity parent token.</param>
    /// <param name="xform">Xform.</param>
    /// <param name="positionsNum">Number of positions.</param>
    /// <param name="positions">Positions.</param>
    /// <param name="normalsNum">Number of normals.</param>
    /// <param name="normals">Normals.</param>
    /// <param name="facesetsNum">Number of facesets.</param>
    /// <param name="facesets">Facesets.</param>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct MeshData
    {
        [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] public string entityToken;
        [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] public string displayName;
        [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] public string entityParentToken;
        public System.UIntPtr positionsNum;
        public System.IntPtr positions;
        public System.UIntPtr normalsNum;
        public System.IntPtr normals;
        public System.IntPtr facesetsNum;
        public System.IntPtr facesets;
        public System.IntPtr uvSetNum;
        public System.IntPtr uvSets;
    }

    /// <summary>
    /// Managed mesh data structure
    /// Used in mesh update and creation methods as a managed memory helper struct
    /// </summary>
    public struct ManagedMeshData
    {
        public Vector3[]                  positions;
        public Vector3[]                  normals;

        public StringCollection           materials;
        public List<int[]>                indices;
        public int                        facesetNum;

        public int                        uvNum;
        public List<int[]>                uvIndices;
        public List< List<Vector2> >      uvs;
    }

    /// <summary>
    /// Faceset data marshalling structure
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct FacesetData
    {
        public ulong indicesNum;
        public System.IntPtr indices;
        [System.Runtime.InteropServices.MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPStr)] public string materialName;
    }

    /// <summary>
    /// Faceset data marshalling structure
    /// </summary>
    [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential)]
    public struct UVData
    {
        public System.IntPtr indices;
        public ulong indicesNum;
        public System.IntPtr uvs;
        public ulong uvsNum;
    }

    /// <summary>
    /// Mesh handler
    /// Static public class used to create or update meshes from STP mesh network Response packets
    /// </summary>
    public static class MeshHandler
    {

        // Obsolete: Unity uses 16-bit index buffers exclusively, so the maximum vertex that can be indexed is (2^15-1).
        // must be a multiple of 3
        // NOTE: This limitation has been overridden from Unity 2018.1, mesh handler is now deciding automatically if we are using
        // 16-bit index buffers or 32-bit index buffers depending on the vertex density of the mesh
        static private readonly int max_vertices_16bit = (2 << 15) - 1;
        static private readonly int max_vertices_32bit = (2 << 29) - 1; // note 29, not 30 (sign bit), as it overflows

        /// <summary>
        /// Define mesh assets generated by STP default path
        /// </summary>
        public static string assetPath = "Foundry/Meshes";

        /// <summary>
        /// Dependency check
        /// Checks if all of the dependencies of the mesh are available in Unity
        /// </summary>
        public static bool DependencyCheck(ManagedMeshData meshData, string entityToken)
        {
            // Check if we have materials available
            for (var i = 0; i < meshData.facesetNum; ++i)
            {
                if (!System.String.IsNullOrEmpty(meshData.materials[i]))
                {
                    // Check if we have a material instance or material definition ready for this mesh
                    if (!PackageMapper.GetMaterialFromToken(meshData.materials[i]))
                    {
                        // TODO: messages slow down the recieve mechanism and spam the log
                        //Debug.LogWarningFormat("Material '{0}' for '{1}' has not yet been created!",
                        //                         meshData.materials[i],
                        //                         entityToken);

                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Manage mesh memory
        /// Converts the marshaled unmanaged mesh memory to managed
        /// </summary>
        public static ManagedMeshData ManageMeshMemory(MeshData meshData)
        {
            ManagedMeshData managedMeshData = new ManagedMeshData();

            managedMeshData.positions = MarshallPositions((int)meshData.positionsNum, meshData.positions);
            managedMeshData.normals = ((int)meshData.normalsNum > 0) ? MarshallNormals((int)meshData.normalsNum, meshData.normals) : null;

            managedMeshData.materials = new StringCollection();
            managedMeshData.indices = new List<int[]>();
            var facesetdataSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(FacesetData));

            var currentReadPtr = meshData.facesets;
            for (var i = 0; i < (int)meshData.facesetsNum; ++i)
            {
                FacesetData fs = (FacesetData)System.Runtime.InteropServices.Marshal.PtrToStructure(currentReadPtr, typeof(FacesetData));
                managedMeshData.materials.Add(fs.materialName);
                managedMeshData.indices.Add(MarshallTriangleIndices((int)fs.indicesNum, fs.indices));
                currentReadPtr = MarshalData.AddToIntPtr(currentReadPtr, facesetdataSize);
            }
            managedMeshData.facesetNum = (int)meshData.facesetsNum;

            managedMeshData.uvs = new List<List<Vector2>>();
            currentReadPtr = meshData.uvSets;
            var uvSetDataSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(UVData));
            for (var i = 0; i < (int)meshData.uvSetNum; ++i)
            {
                UVData uvData = (UVData)System.Runtime.InteropServices.Marshal.PtrToStructure(currentReadPtr, typeof(UVData));
                // Note: Not currently using triangle indices
                //managedMeshData.indices.Add(MarshallTriangleIndices((int)uvData.indicesNum, uvData.indices));
                managedMeshData.uvs.Add(MarshallUVData((int)uvData.uvsNum, uvData.uvs));
                currentReadPtr = MarshalData.AddToIntPtr(currentReadPtr, uvSetDataSize);
            }
            managedMeshData.uvNum = (int)meshData.uvSetNum;

            return managedMeshData;
        }

        /// <summary>
        /// Update mesh
        /// Function that goes through the process of updating existing mesh item.
        /// Checking for unindexed or indexed meshes.
        /// </summary>
        public static bool UpdateMesh(MeshData meshData, ManagedMeshData managedMeshData)
        {
            Debug.LogFormat("Mesh Update - Token:{0}, Parent:{1}, {2} positions, {3} facesets", meshData.entityToken, meshData.entityParentToken, meshData.positionsNum, meshData.facesetsNum);

            // Find existing mesh
            Mesh mesh = PackageMapper.GetMeshFromToken(meshData.entityToken);

            if (!mesh)
            {
                return false;
            }

            // Get the index format of the mesh
            UnityEngine.Rendering.IndexFormat indexFormat;
            int maxVertexLimitSplit;
            GetIndexBufferConfiguration(
                managedMeshData.positions.Length,
                out indexFormat,
                out maxVertexLimitSplit);

            // Get the prefab object
            GameObject prefab = PackageMapper.GetObjectFromToken(meshData.entityToken) as GameObject;

            // Check if we need to split the mesh
            if (maxVertexLimitSplit == 0)
            {
                // Update existing mesh
                UpdateMeshData(
                    managedMeshData.positions,
                    managedMeshData.normals,
                    managedMeshData.uvs,
                    managedMeshData.facesetNum,
                    managedMeshData.indices,
                    indexFormat,
                    ref mesh
                );

                UpdateSimpleMeshAsset(
                    meshData.entityToken,
                    meshData.displayName,
                    managedMeshData,
                    mesh,
                    prefab
                );
            }
            else
            {
                // Delete prefab first
                AssetDatabase.DeleteAsset(AssetDatabase.GetAssetPath(prefab));

                // Create split mesh assets, create hierarchy of prefabs
                // and add the root prefab to the package mapper
                List<Mesh> meshList = CreateSplitMeshes(
                    meshData.entityToken,
                    meshData.displayName,
                    managedMeshData
                );

                CreateSplitMeshAsset(
                    meshData.entityToken,
                    meshData.displayName,
                    meshData.entityParentToken,
                    managedMeshData.facesetNum,
                    managedMeshData.materials,
                    meshList);
            }

            mesh.UploadMeshData(false);

            return true;
        }

        /// <summary>
        /// Create mesh
        /// Function that goes through the process of creating new mesh items.
        /// </summary>
        public static bool CreateMesh(MeshData meshData, ManagedMeshData managedMeshData)
        {
            Debug.LogFormat("Mesh - Token:{0}, Parent:{1}, {2} positions, {3} facesets", meshData.entityToken, meshData.entityParentToken, meshData.positionsNum, meshData.facesetsNum);

            // Get the index format of the mesh
            UnityEngine.Rendering.IndexFormat indexFormat;
            int maxVertexLimitSplit;
            GetIndexBufferConfiguration(
                managedMeshData.positions.Length,
                out indexFormat,
                out maxVertexLimitSplit);

            // Check if we need to split the mesh
            if (maxVertexLimitSplit == 0)
            {
                // Create simple mesh asset, create it's prefab object
                // and add it to the package mapper
                Mesh newMesh = new Mesh();
                UpdateMeshData(
                    managedMeshData.positions,
                    managedMeshData.normals,
                    managedMeshData.uvs,
                    managedMeshData.facesetNum,
                    managedMeshData.indices,
                    indexFormat,
                    ref newMesh
                );

                CreateSimpleMeshAsset(
                    meshData.entityToken,
                    meshData.entityParentToken,
                    meshData.displayName,
                    managedMeshData.facesetNum,
                    managedMeshData.materials,
                    newMesh);
            }
            else
            {
                // Create split mesh assets, create hierarchy of prefabs
                // and add the root prefab to the package mapper
                List<Mesh> meshList = CreateSplitMeshes(
                    meshData.entityToken,
                    meshData.displayName,
                    managedMeshData
                );

                CreateSplitMeshAsset(
                    meshData.entityToken,
                    meshData.displayName,
                    meshData.entityParentToken,
                    managedMeshData.facesetNum,
                    managedMeshData.materials,
                    meshList);
            }

            return true;
        }

        /// <summary>
        /// Update mesh data
        /// Used to update the mesh data of a Unity mesh item
        /// Only position vertex attributes are currently supported.
        /// Submeshes are used to create facesets.
        /// </summary>
        private static bool
        UpdateMeshData(
            Vector3[] positions,
            Vector3[] normals,
            List<List<Vector2>> uvs,
            int numFacesets,
            List<int[]> indices,
            UnityEngine.Rendering.IndexFormat indexFormat,
            ref Mesh mesh)
        {
            // specify some vertices
            mesh.vertices = positions;
            mesh.normals = normals;
            mesh.indexFormat = indexFormat;

            // set each UV set
            // mesh class assumes that each uv is corresponding to the polygon vertex
            // indice, so we are not using uv indices provided by STP
            for (var i = 0; i < uvs.Count; i++)
            {
                mesh.SetUVs(i, uvs[i]);
            }

            // must call this before assigning indices through SetTriangles or Unity won't notice > 1 submeshes
            mesh.subMeshCount = numFacesets;
            // per face-set indices
            for (var i = 0; i < numFacesets; ++i)
            {
                // Flip array of indices to account for cordinate system change
                FlipWindingArray(indices[i], indices[i].Length);
                mesh.SetTriangles(indices[i], i);
            }
            if (null == normals)
            {
                // only recalculate normals when there are none
                mesh.RecalculateNormals();
            }
            mesh.RecalculateTangents(); // we never pass tangents, so let's build them (in case any shader requires them)

            return true;
        }

        /// <summary>
        /// Create simple mesh asset
        /// Used to create the assets of a referenced Unity mesh item
        /// We create two asset parts, first a Unity mesh asset in the set path
        /// And second a prefab made from the temporary GameObject of the created mesh asset
        /// Mesh prefab is used to store unique token information for that mesh and other data
        /// as materials and other.
        /// </summary>
        private static bool
        CreateSimpleMeshAsset(
            string entityToken,
            string parentToken,
            string displayName,
            int numFacesets,
            StringCollection materialNames,
            Mesh mesh)
        {
            Material[] materials = GetMeshMaterials(numFacesets, materialNames, entityToken);

            // Add mesh name
            mesh.name = displayName;

            // Create asset folders if they are non existant
            PackageMapper.CreateAssetFolders(MeshHandler.assetPath);

            GameObject meshPrefab = new GameObject();

            meshPrefab.AddComponent<MeshFilter>();
            var meshRenderer = meshPrefab.AddComponent<MeshRenderer>();
            meshRenderer.materials = materials;
            var meshTokenComp = meshPrefab.AddComponent<FoundryUniqueToken>();
            meshTokenComp.uniqueToken = entityToken;

            // Create the mesh asset prefab
            var localPath = System.String.Format("{0}/{1}/{2}", PackageMapper.rootPath, MeshHandler.assetPath, displayName);
            string prefabPath;
            PackageMapper.GenUniquePrefabAssetPath(localPath, out prefabPath);
#if UNITY_2018_3_OR_NEWER
            GameObject prefab = PrefabUtility.SaveAsPrefabAsset(meshPrefab, prefabPath);
#else
            GameObject prefab = PrefabUtility.CreatePrefab(prefabPath, meshPrefab);
#endif

            // Add the mesh object to the prefab
            AssetDatabase.AddObjectToAsset(mesh, prefab);

            // Need to add mesh after being added to the asset or it will disappear in the prefab
            prefab.GetComponent<MeshFilter>().mesh = mesh;

            AssetDatabase.SaveAssets();

            // Remove game object that's used for creating a prefab from scene hierarchy
            Object.DestroyImmediate(meshPrefab);

            // Map the mesh prefab to unique token 
            PackageMapper.MapTokenToObject(entityToken, prefab);
            PackageMapper.MapMeshToPrefab(mesh, prefab);

            return true;
        }

        /// <summary>
        /// Update simple mesh asset
        /// Used to update the existing mesh assets of a Unity mesh item
        /// </summary>
        private static bool
        UpdateSimpleMeshAsset(
            string entityToken,
            string displayName,
            ManagedMeshData managedMeshData,
            Mesh mesh,
            GameObject meshPrefab)
        {
            // Update the mesh renderer
            Material[] materials = GetMeshMaterials(managedMeshData.facesetNum, managedMeshData.materials, entityToken);

            var meshRenderer = meshPrefab.GetComponent<MeshRenderer>();
            if (meshRenderer)
            {
                meshRenderer.materials = materials;
            }

            // Update mesh name
            mesh.name = displayName;

            AssetDatabase.SaveAssets();

            return true;
        }

        /// <summary>
        /// Create split meshes
        /// Creates a list of split Unity mesh objects.
        /// </summary>
        private static List<Mesh>
        CreateSplitMeshes(
            string entityToken,
            string displayName,
            ManagedMeshData managedMeshData)
        {
            List<Mesh> meshList = new List<Mesh>();

            int max_vertex_limit_split;
            UnityEngine.Rendering.IndexFormat indexFormat;
            GetIndexBufferConfiguration(
                    managedMeshData.positions.Length,
                    out indexFormat,
                    out max_vertex_limit_split);

            // now split the geometry into N meshes, as children of this new game object, and the identity transform
            var current_offset = 0;
            var remaining_vertices = managedMeshData.positions.Length;
            var split_index = 0;
            while (remaining_vertices > 0)
            {
                var segment_size = System.Math.Min(remaining_vertices, max_vertex_limit_split);
                var positionSegment = CopyArraySegment(managedMeshData.positions, current_offset, segment_size);
                var normalSegment = CopyArraySegment(managedMeshData.normals, current_offset, segment_size);

                if (positionSegment == null || normalSegment == null)
                {
                    throw new System.Exception(System.String.Format("Unindexed mesh creation failure! Token:{0} Name:{1} Part:{2}", entityToken, displayName, System.String.Format("Split_{0}", split_index)));
                }

                var indicesSegment = new List<int[]>();
                for (var i = 0; i < managedMeshData.indices.Count; ++i)
                {
                    var segment = CopyArraySegmentAndRebase(managedMeshData.indices[i], current_offset, segment_size);
                    if (segment == null)
                    {
                        throw new System.Exception(System.String.Format("Unindexed mesh creation failure! Token:{0} Name:{1} Part:{2}", entityToken, displayName, System.String.Format("Split_{0}", split_index)));
                    }

                    indicesSegment.Add(segment);
                }

                var uvSegment = new List< List<Vector2> >();
                for (var i = 0; i < managedMeshData.uvNum; ++i)
                {
                    uvSegment.Add(CopyListSegment(managedMeshData.uvs[i], current_offset, segment_size));
                }

                Mesh mesh = new Mesh();
                UpdateMeshData(
                    positionSegment,
                    normalSegment,
                    uvSegment,
                    managedMeshData.facesetNum,
                    indicesSegment,
                    indexFormat,
                    ref mesh);

                if (!mesh)
                {
                    throw new System.Exception(System.String.Format("Unindexed mesh creation failure! Token:{0} Name:{1} Part:{2}", entityToken, displayName, System.String.Format("Split_{0}", split_index)));
                }

                meshList.Add(mesh);

                current_offset += segment_size;
                remaining_vertices -= segment_size;
                ++split_index;
            }

            return meshList;
        }

        /// <summary>
        /// Create unindexed mesh asset
        /// Used to create the assets of a referenced Unity mesh item
        /// We create two asset parts, first a Unity mesh asset in the set path
        /// And second a prefab made from the temporary GameObject of the created mesh asset
        /// Mesh prefab is used to store unique token information for that mesh and other data
        /// as materials and other.
        /// 
        /// Difference between simple and unindexed mesh assets is that the vertex data for unindexed meshes is completely unwelded.
        /// </summary>
        private static bool CreateSplitMeshAsset(
            string entityToken,
            string displayName,
            string parentToken,
            int numFacesets,
            StringCollection materialNames,
            List<Mesh> meshList)
        {
            // specify how to render it, one material per faceset
            var materials = GetMeshMaterials(numFacesets, materialNames, entityToken);

            // Create root GameObject and add child GameObjects for each mesh generated
            // Root
            // ---- Mesh_Split_1
            // ---- Mesh_Split_2
            // ---- etc...
            GameObject rootObj = new GameObject(displayName);

            Transform rootTrs = rootObj.transform;
            var rootTokenStore = rootObj.AddComponent<FoundryUniqueToken>();
            rootTokenStore.uniqueToken = entityToken;

            // Create asset folders if they are non existant
            PackageMapper.CreateAssetFolders(MeshHandler.assetPath);

            // Create GameObject hierarchy
            int splitNum = 1;
            foreach (var mesh in meshList)
            {
                // Create the mesh asset
                string gameObjectDisplayName;
                GameObject meshPrefab;

                // If we split this mesh create a game object for each part
                // else just populate the root object
                if (meshList.Count > 1)
                {
                    gameObjectDisplayName = System.String.Format("{0}_Split{1}", displayName, splitNum);

                    // Create mesh game object
                    meshPrefab = new GameObject(gameObjectDisplayName);

                    //Parent to the root game object
                    meshPrefab.transform.SetParent(rootTrs);
                }
                else
                {
                    gameObjectDisplayName = displayName;
                    meshPrefab = rootObj;
                }

                meshPrefab.AddComponent<MeshFilter>();
                var meshRenderer = meshPrefab.AddComponent<MeshRenderer>();
                meshRenderer.materials = materials;

                mesh.name = gameObjectDisplayName;

                splitNum++;
            }

            // Create the prefab asset
            var localPrefabPath = System.String.Format("{0}/{1}/{2}", PackageMapper.rootPath, MeshHandler.assetPath, displayName);
            string prefabPath;
            PackageMapper.GenUniquePrefabAssetPath(localPrefabPath, out prefabPath);
#if UNITY_2018_3_OR_NEWER
            GameObject prefabAsset = PrefabUtility.SaveAsPrefabAsset(rootObj, prefabPath);
#else
            GameObject prefabAsset = PrefabUtility.CreatePrefab(prefabPath, rootObj);
#endif

            List<MeshFilter> results = new List<MeshFilter>();
            prefabAsset.GetComponentsInChildren<MeshFilter>(results);

            int i = 0;
            foreach (var mesh in meshList)
            {
                AssetDatabase.AddObjectToAsset(mesh, prefabAsset);
                results[i].mesh = mesh;
                i++;
            }

            AssetDatabase.SaveAssets();

            // Remove game object that's used for creating a prefab from scene hierarchy
            Object.DestroyImmediate(rootObj);

            // Map the mesh prefab to unique token 
            PackageMapper.MapTokenToObject(entityToken, prefabAsset);
            PackageMapper.MapMeshToPrefab(meshList[0], prefabAsset);

            return true;
        }

        private static void
        GetIndexBufferConfiguration(
            int num_positions,
            out UnityEngine.Rendering.IndexFormat index_format,
            out int max_vertex_limit_split)
        {
            if (num_positions > max_vertices_16bit)
            {
                if (SystemInfo.supports32bitsIndexBuffer)
                {
                    index_format = UnityEngine.Rendering.IndexFormat.UInt32;
                    if (num_positions > max_vertices_32bit)
                    {
                        max_vertex_limit_split = max_vertices_32bit;
                    }
                    else
                    {
                        max_vertex_limit_split = 0; // no split
                    }
                }
                else
                {
                    index_format = UnityEngine.Rendering.IndexFormat.UInt16;
                    max_vertex_limit_split = max_vertices_16bit;
                }
            }
            else
            {
                index_format = UnityEngine.Rendering.IndexFormat.UInt16;
                max_vertex_limit_split = 0; // 0 == no split
            }
        }

        private static T[] CopyArraySegment<T>(
            T[] src_array,
            int base_index,
            int length)
        {
            if (null == src_array)
            {
                return null;
            }
            var array = new T[length];
            for (var i = 0; i < length; ++i)
            {
                array[i] = src_array[base_index + i];
            }
            return array;
        }

        private static List<T> CopyListSegment<T>(
            List<T> srcList,
            int     base_index,
            int     length)
        {
            if (null == srcList)
            {
                return null;
            }
            var list = new List<T>(length);
            for (var i = 0; i < length; ++i)
            {
                list[i] = srcList[base_index + i];
            }
            return list;
        }

        private static int[] CopyArraySegmentAndRebase(
            int[] src_array,
            int base_index,
            int length)
        {
            if (null == src_array)
            {
                return null;
            }
            var array = new int[length];
            for (var i = 0; i < length; ++i)
            {
                array[i] = src_array[base_index + i] - base_index;
            }
            return array;
        }

        private static void FlipWindingArray<T>(
            T[] srcArray,
            int length)
        {
            if (null == srcArray)
            {
                return;
            }

            // Assuming we are only having triangles
            for (var i = 0; i < length; i += 3)
            {
                var index0 = srcArray[i];
                var index1 = srcArray[i + 1];
                var index2 = srcArray[i + 2];

                srcArray[i] = index0;
                srcArray[i + 2] = index1;
                srcArray[i + 1] = index2;
            }
        }

        private static void FlipWindingList<T>(List<T> srcArray)
        {
            if (null == srcArray)
            {
                return;
            }

            // Assuming we are only having triangles
            for (var i = 0; i < srcArray.Count; i += 3)
            {
                var index0 = srcArray[i];
                var index1 = srcArray[i + 1];
                var index2 = srcArray[i + 2];

                srcArray[i] = index0;
                srcArray[i + 2] = index1;
                srcArray[i + 1] = index2;
            }
        }

        /// <summary>
        /// Get mesh materials
        /// Function checks for mesh materials by unique tokens and adds them to a list.
        /// </summary>
        private static Material[] GetMeshMaterials(int numFacesets, StringCollection materialNames, string entityToken)
        {
            // specify how to render it, one material per faceset
            var materials = new Material[numFacesets];
            for (var i = 0; i < numFacesets; ++i)
            {
                Material material = null;
                if (!System.String.IsNullOrEmpty(materialNames[i]))
                {
                    material = PackageMapper.GetMaterialFromToken(materialNames[i]);
                    if (!material)
                    {
                        throw new System.Exception(
                            System.String.Format("Material '{0}' for '{1}' has not yet been created!",
                                                 materialNames[i],
                                                 entityToken));
                    }
                }
                else
                {
                    material = DefaultAssets.DiffuseMaterial;
                }
                materials[i] = material;
            }

            return materials;
        }

        /// <summary>
        /// 
        /// Marshal data methods
        /// 
        /// </summary>
        public static Vector3[] MarshallPositions(int numPositions, System.IntPtr positions)
        {
            var managed_positions = new Vector3[numPositions];
            int positionOffset = 0;

            // translate unmanaged position data into managed Vector3s
            for (var i = 0; i < numPositions; ++i)
            {
                var x = MarshalData.GetFloatFromUnmanagedArray(positions, positionOffset);
                positionOffset += MarshalData.sizeOfInt;
                var y = MarshalData.GetFloatFromUnmanagedArray(positions, positionOffset);
                positionOffset += MarshalData.sizeOfInt;
                var z = MarshalData.GetFloatFromUnmanagedArray(positions, positionOffset);
                positionOffset += MarshalData.sizeOfInt;

                managed_positions[i] = new Vector3(x, z, -y);
                managed_positions[i].Scale(MarshalData.scaleFromSTPtoUnity);
            }
            return managed_positions;
        }

        public static Vector3[] MarshallNormals(int num_normals, System.IntPtr normals)
        {
            var managed_normals = new Vector3[num_normals];
            int normalOffset = 0;

            // translate unmanaged normal data into managed Vector3s
            for (var i = 0; i < num_normals; ++i)
            {
                var x = MarshalData.GetFloatFromUnmanagedArray(normals, normalOffset);
                normalOffset += MarshalData.sizeOfInt;
                var y = MarshalData.GetFloatFromUnmanagedArray(normals, normalOffset);
                normalOffset += MarshalData.sizeOfInt;
                var z = MarshalData.GetFloatFromUnmanagedArray(normals, normalOffset);
                normalOffset += MarshalData.sizeOfInt;

                managed_normals[i] = new Vector3(x, z, -y);
            }

            return managed_normals;
        }

        public static int[] MarshallTriangleIndices(int numIndices, System.IntPtr indices)
        {
            var managedIndices = new int[numIndices];
            int index_offset = 0;
            // This part could be optimized by not needing to change the winding order
            for (var i = 0; i < numIndices; i++)
            {
                var index0 = MarshalData.GetIntFromUnmanagedArray(indices, index_offset);
                index_offset += MarshalData.sizeOfInt;

                managedIndices[i] = index0;
            }
            return managedIndices;
        }

        public static List<Vector2> MarshallUVData(int numUVs, System.IntPtr uvData)
        {
            var managedUVData = new List<Vector2>();
            int index_offset = 0;
            // This part could be optimized by not needing to change the winding order
            for (var i = 0; i < numUVs; i += 2)
            {
                var u = MarshalData.GetFloatFromUnmanagedArray(uvData, index_offset);
                index_offset += MarshalData.sizeOfInt;
                var v = 1.0f - MarshalData.GetFloatFromUnmanagedArray(uvData, index_offset);
                index_offset += MarshalData.sizeOfInt;

                managedUVData.Add(new Vector2(u, v));
            }

            return managedUVData;
        }

        // Data stride defines
        static private readonly int verticesDataStride = 3;
        static private readonly int normalsDataStride = 3;
        static private readonly int indicesStride = 3;
        static private readonly int uvDataStride = 2;

        // Max mesh uvs
        static private readonly int maxUV = 7;

        public static void CreateAndSendMeshRequest(Mesh mesh, List<string> materialTokens, string token)
        {
            MeshData meshData = new MeshData();

            meshData.entityToken = token;
            meshData.entityParentToken = "";
            meshData.displayName = mesh.name;

            // Add positions, first convert from Unity to STP
            Vector3[] vertices = new Vector3[mesh.vertices.Length];
            System.Array.Copy(mesh.vertices, vertices, mesh.vertices.Length);
            int vertCount = vertices.Length;
            for (int i = vertCount - 1; i >= 0; i--)
            {
                float tempY = vertices[i].y;
                vertices[i].y = -vertices[i].z;
                vertices[i].z = tempY;
                vertices[i].Scale(MarshalData.scaleFromUnitytoSTP);
            }

            System.Runtime.InteropServices.GCHandle pinnedVerticesArray =
            System.Runtime.InteropServices.GCHandle.Alloc(vertices, System.Runtime.InteropServices.GCHandleType.Pinned);
            meshData.positions = pinnedVerticesArray.AddrOfPinnedObject();
            meshData.positionsNum = (System.UIntPtr)(vertices.Length * verticesDataStride);

            // Add normals
            Vector3[] normals = new Vector3[mesh.normals.Length];
            System.Array.Copy(mesh.normals, normals, mesh.normals.Length);
            int normalCount = mesh.normals.Length;
            for (int i = normalCount - 1; i >= 0; i--)
            {
                float tempY = normals[i].y;
                normals[i].y = -normals[i].z;
                normals[i].z = tempY;
            }

            System.Runtime.InteropServices.GCHandle pinnedNormalsArray =
            System.Runtime.InteropServices.GCHandle.Alloc(normals, System.Runtime.InteropServices.GCHandleType.Pinned);
            meshData.normals = pinnedNormalsArray.AddrOfPinnedObject();
            meshData.normalsNum = (System.UIntPtr)(normals.Length * normalsDataStride);

            // Add indices
            meshData.facesetsNum = (System.IntPtr)mesh.subMeshCount;
            System.Runtime.InteropServices.GCHandle[] pinnedIndicesArrays = new System.Runtime.InteropServices.GCHandle[(int)meshData.facesetsNum];

            // Add facesets
            FacesetData[] faceSets = new FacesetData[(int)meshData.facesetsNum];
            int structSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(FacesetData));
            meshData.facesets = System.Runtime.InteropServices.Marshal.AllocHGlobal((int)meshData.facesetsNum * structSize);
            System.IntPtr facesetsPtr = meshData.facesets;

            // Change the winding order of indices
            int[][] indices = new int[(int)meshData.facesetsNum][];
            var materialNum = materialTokens.Count;
            for (var i = 0; i < (int)meshData.facesetsNum; ++i)
            {
                int[] indicesList = mesh.GetTriangles(i);
                indices[i] = new int[indicesList.Length];
                for (var indicePos = 0; indicePos < indicesList.Length; indicePos += indicesStride)
                {
                    indices[i][indicePos + 0] = indicesList[indicePos + 0];
                    indices[i][indicePos + 1] = indicesList[indicePos + 2];
                    indices[i][indicePos + 2] = indicesList[indicePos + 1];
                }

                pinnedIndicesArrays[i] =
                    System.Runtime.InteropServices.GCHandle.Alloc(
                        indices[i], 
                        System.Runtime.InteropServices.GCHandleType.Pinned
                    );
                faceSets[i].indices = pinnedIndicesArrays[i].AddrOfPinnedObject();

                // Marshaling needs to use UIntPtr for size_t
                int indicesNum = indicesList.Length;
                //faceSets[i].indicesNum = (System.UIntPtr)indicesNum;
                faceSets[i].indicesNum = (ulong)indicesNum;

                // Marshal material tokens
                if (i < materialNum)
                {
                    faceSets[i].materialName = materialTokens[i];
                }
                else
                {
                    faceSets[i].materialName = "";
                }

                System.Runtime.InteropServices.Marshal.StructureToPtr(faceSets[i], facesetsPtr, false);
                facesetsPtr = (System.IntPtr)((long)facesetsPtr + structSize);
            }

            // Add UVs
            List<Vector2>[] meshUVs = new List<Vector2>[maxUV];
            int uvCount = 0;
            for (int i = 0; i < maxUV; i++)
            {
                meshUVs[i] = new List<Vector2>();
                mesh.GetUVs(i, meshUVs[i]);

                if (meshUVs[i].Count == 0)
                {
                    break;
                }

                uvCount++;
            }

            UVData[] uvSets = new UVData[uvCount];
            float[][] uvDataArr = new float[uvCount][];
            structSize = System.Runtime.InteropServices.Marshal.SizeOf(typeof(UVData));
            meshData.uvSetNum = (System.IntPtr)uvCount;
            meshData.uvSets = System.Runtime.InteropServices.Marshal.AllocHGlobal(uvCount * structSize);
            System.IntPtr uvSetsPtr = meshData.uvSets;

            System.Runtime.InteropServices.GCHandle[] pinnedUVArrays = new System.Runtime.InteropServices.GCHandle[uvCount];

            for (int i = 0; i < uvCount; i++)
            {
                uvDataArr[i] = new float[meshUVs[i].Count * uvDataStride];

                for (int uvInd = 0; uvInd < meshUVs[i].Count; uvInd++)
                {
                    int uvDataInd = uvInd * uvDataStride;
                    uvDataArr[i][uvDataInd] = meshUVs[i][uvInd].x;
                    uvDataArr[i][uvDataInd + 1] = 1.0f - meshUVs[i][uvInd].y; // Convert UV from Unity to STP
                }

                // We are not using UV indices due to Unity not supporting them
                uvSets[i].indicesNum = 0;

                pinnedUVArrays[i] =
                    System.Runtime.InteropServices.GCHandle.Alloc(
                        uvDataArr[i],
                        System.Runtime.InteropServices.GCHandleType.Pinned
                    );
                uvSets[i].uvs = pinnedUVArrays[i].AddrOfPinnedObject();
                uvSets[i].uvsNum = (ulong)uvDataArr[i].Length;

                System.Runtime.InteropServices.Marshal.StructureToPtr(uvSets[i], uvSetsPtr, false);
                uvSetsPtr = (System.IntPtr)((long)uvSetsPtr + structSize);
            }

            System.IntPtr meshDataPtr = System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Runtime.InteropServices.Marshal.SizeOf(meshData));
            System.Runtime.InteropServices.Marshal.StructureToPtr(meshData, meshDataPtr, false);

            Debug.LogFormat("Mesh Push - Token:{0}, Parent:{1}, {2} positions, {3} facesets", meshData.entityToken, meshData.entityParentToken, (int)meshData.positionsNum, (int)meshData.facesetsNum);
            ImportMenu.stpUnitySendMeshData(meshDataPtr);

            // Free memory
            pinnedVerticesArray.Free();
            pinnedNormalsArray.Free();

            foreach(var pin in pinnedIndicesArrays)
            {
                pin.Free();
            }

            System.Runtime.InteropServices.Marshal.FreeHGlobal(meshData.facesets);
            System.Runtime.InteropServices.Marshal.FreeHGlobal(meshDataPtr);
        }

    }
}
